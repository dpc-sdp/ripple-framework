import{a5 as x,r as d,a6 as C,a7 as b,a8 as O,a as m,Z as k,a9 as B,j as D,aa as H,N as M,ab as R,ac as A}from"./entry.DDxZgYGk.js";const E=n=>n==="defer"||n===!1;function z(...n){var h;const l=typeof n[n.length-1]=="string"?n.pop():void 0;typeof n[0]!="string"&&n.unshift(l);let[a,u,e={}]=n;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=D(),v=u,_=()=>null,g=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??_,e.getCachedData=e.getCachedData??g,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??x.deep,e.dedupe=e.dedupe??"cancel";const f=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(h=t.payload._errors)[a]??(h[a]=null);const o=e.deep?d:C;t._asyncData[a]={data:o(e.getCachedData(a)??e.default()),pending:d(!f()),error:b(t.payload._errors,a),status:d("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(o={})=>{if(t._asyncDataPromises[a]){if(E(o.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((o._initial||t.isHydrating&&o._initial!==!1)&&f())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const c=new Promise((r,i)=>{try{r(v(t))}catch(w){i(w)}}).then(r=>{if(c.cancelled)return t._asyncDataPromises[a];let i=r;e.transform&&(i=e.transform(r)),e.pick&&(i=N(i,e.pick)),t.payload.data[a]=i,s.data.value=i,s.error.value=null,s.status.value="success"}).catch(r=>{if(c.cancelled)return t._asyncDataPromises[a];s.error.value=H(r),s.data.value=M(e.default()),s.status.value="error"}).finally(()=>{c.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=c,t._asyncDataPromises[a]};const y=()=>s.refresh({_initial:!0}),P=e.server!==!1&&t.payload.serverRendered;{const o=R();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const r=o._nuxtOnBeforeMountCbs;o&&(O(()=>{r.forEach(i=>{i()}),r.splice(0,r.length)}),m(()=>r.splice(0,r.length)))}P&&t.isHydrating&&(s.error.value||f())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(y):e.immediate&&y(),e.watch&&k(e.watch,()=>s.refresh());const c=t.hook("app:data:refresh",async r=>{(!r||r.includes(a))&&await s.refresh()});o&&m(c)}const p=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(p,s),p}async function T(n){await new Promise(a=>B(a));const l=n?A(n):void 0;await D().hooks.callHookParallel("app:data:refresh",l)}function N(n,l){const a={};for(const u of l)a[u]=n[u];return a}export{T as r,z as u};
